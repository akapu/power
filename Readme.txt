ЛАБОРАТОРНАЯ РАБОТА "Нахождение пути на орграфе поиском сначала в глубину (DFS)"

Прочитать из файла данные о вершинах графа и связности, заполнив структуры типа NODE:

typedef struct node {
  char * data;
  struct node *list;
  unsigned char color; 
} NODE;

Представление в файле: в каждой строке указывается номер вершины, строка данных (без пробелов или в двойных кавычках),
 список номеров вершин, с которыми связана данная, например:

1 first 2 4
2 second 4 5
3 third 1 4
4 fourth 0
5 "twenty one" 0

Ввести с консоли начальную и конечную вершины искомого пути (номера вершин).

Вывести результат на консоль, - список вершин, входящих в путь или «no solution». если пути не существует.
 Для поиска использовать алгоритм поиска в глубину (DFS).
При поиске в глубину посещается первая вершина, затем необходимо идти вдоль ребер графа, до попадания в тупик. 
Вершина графа является тупиком, если все смежные с ней вершины уже посещены. 
После попадания в тупик нужно возвращаться назад вдоль пройденного пути, 
пока не будет обнаружена вершина, у которой есть еще не посещенная вершина, 
а затем необходимо двигаться в этом новом направлении. 
Процесс оказывается завершенным при возвращении в начальную вершину, причем все смежные 
с ней вершины уже должны быть посещены.

Таким образом, основная идея поиска в глубину – когда возможные пути по ребрам, 
выходящим из вершин, разветвляются, нужно сначала полностью исследовать одну ветку 
и только потом переходить к другим веткам (если они останутся нерассмотренными).

Алгоритм поиска в глубину

Шаг 1. Всем вершинам графа присваивается значение не посещенная (белый цвет). 
Выбирается первая вершина и помечается как посещенная(черный цвет).

Шаг 2. Для последней помеченной как посещенная вершины выбирается смежная вершина,
 являющаяся первой помеченной как не посещенная (белая), и ей присваивается значение посещенная. 
Если таких вершин нет, то берется предыдущая помеченная (черная) вершина.

Шаг 3. Повторить шаг 2 до тех пор, пока все вершины не будут помечены как посещенные 
Если необходимо, добавить новые элементы в структуру NODE.

